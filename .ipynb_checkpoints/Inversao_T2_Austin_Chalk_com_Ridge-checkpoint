{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 50,
   "id": "b6800e29-6fdd-4bd4-8481-4f5ec1ee65c5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "       Time    Signal\n",
      "0  0.000977  0.985451\n",
      "1  0.001953  0.971115\n",
      "2  0.002930  0.957016\n",
      "3  0.003906  0.943194\n",
      "4  0.004883  0.929659\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "\n",
    "#definição do caminho até o arquivo\n",
    "file_name = 'datas/FEM_T2_AC.csv'\n",
    "\n",
    "#tentativa de leitura desse arquivo\n",
    "try:\n",
    "    #armazenamos a leitura dos dados do arquivo na variável 'datas'\n",
    "    #o arquivo .csv nãa tem o header, por isso do 'header=None'\n",
    "    datas = pd.read_csv(file_name, header=None)\n",
    "\n",
    "    #criação de um nome para as colunas, sendo a primeira 'Time' e a segunda 'Signal'\n",
    "    datas.columns = ['Time', 'Signal']\n",
    "\n",
    "    #verificação para ver os 5 primeiros dados\n",
    "    print(datas.head())\n",
    "\n",
    "#caso não consiga acessar o arquivo\n",
    "except FileNotFoundError:\n",
    "    print(f\"ERRO: O arquivo em '{file_name}' não foi encontrado!\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "id": "4ce31f82-d7f8-412c-ab2d-8c3e57591e86",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "       Time    Signal  Signal_Noisy\n",
      "0  0.000977  0.985451      1.155600\n",
      "1  0.001953  0.971115      0.684187\n",
      "2  0.002930  0.957016      1.006706\n",
      "3  0.003906  0.943194      1.102994\n",
      "4  0.004883  0.929659      0.825118\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "\n",
    "#ruido (desvio padrão) definido como 0.1\n",
    "standard_deviation = 0.1\n",
    "\n",
    "#criação da variável 'noise' que armazena um vetor até de tamanho 'len(datas'\n",
    "#valores que estão distribuidos de forma normal com média centrada no 0 e desvio padrão de 0.1\n",
    "noise = np.random.normal(0, standard_deviation, len(datas))\n",
    "\n",
    "#criação de uma coluna com esses dados alterados\n",
    "datas['Signal_Noisy'] = datas['Signal'] + noise\n",
    "\n",
    "#verificação para ver os 5 primeiros dados\n",
    "print(datas.head())\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "id": "af4cfa14-0078-4916-8698-eca7c1477da7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "          Time        Signal  Signal_Noisy\n",
      "3711  3.625000  6.934807e-08      0.043649\n",
      "2165  2.115234  1.965072e-05     -0.121884\n",
      "1061  1.037109  1.589752e-03     -0.040268\n",
      "2220  2.168945  1.598531e-05     -0.195882\n",
      "2864  2.797852  1.482981e-06      0.114048\n",
      "\n",
      "\n",
      "       Time        Signal  Signal_Noisy\n",
      "0  3.625000  6.934807e-08      0.043649\n",
      "1  2.115234  1.965072e-05     -0.121884\n",
      "2  1.037109  1.589752e-03     -0.040268\n",
      "3  2.168945  1.598531e-05     -0.195882\n",
      "4  2.797852  1.482981e-06      0.114048\n"
     ]
    }
   ],
   "source": [
    "#variável que recebe o tamanho de 'datas'\n",
    "N = len(datas)\n",
    "\n",
    "#variável que armazena um vetor de valores de maneira permutada de tamanho N\n",
    "shuffler = np.random.permutation(N)\n",
    "\n",
    "#criação de uma variável com os dados rearranjados, mas o indice continua bagunçado\n",
    "datas_shuffled = datas.iloc[shuffler]\n",
    "\n",
    "#verificação para ver os 5 primeiros dados dessa nova variável com os indices bagunçados\n",
    "print(datas_shuffled.head())\n",
    "print(f'\\n')\n",
    "\n",
    "#agora atualizamos o índice para manter o bom andamento do código\n",
    "datas_shuffled = datas_shuffled.reset_index(drop = True)\n",
    "\n",
    "#verificação para ver os 5 primeiros dados dessa nova variável com os indices atualizados\n",
    "print(datas_shuffled.head())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "id": "e675f8d7-ab7d-4493-b959-a032b5986a89",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "X_train = (3276, 1)\n",
      "X_test = (820, 1)\n",
      "y_train = (3276,)\n",
      "y_test = (820,)\n"
     ]
    }
   ],
   "source": [
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "#criação do X e do y para fazermos os testes\n",
    "#é necessário o uso de '[[]]' no X por conta do formato que o scikit-leatn foi projetada\n",
    "X = datas_shuffled[['Time']]\n",
    "y = datas_shuffled['Signal_Noisy']\n",
    "\n",
    "#divisão dos dados para treinos e testes, utilizando de 20% dos dados para testes\n",
    "#a utilização do 'random_state = 42' é uma convenção, é necessário utilizar para mantermos uma consistência \n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 42)\n",
    "\n",
    "#verificação para ver a forma dos dados de treino e teste \n",
    "print(f\"X_train = {X_train.shape}\")\n",
    "print(f\"X_test = {X_test.shape}\")\n",
    "print(f\"y_train = {y_train.shape}\")\n",
    "print(f\"y_test = {y_test.shape}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "id": "68e68e7b-fd22-4bc3-bed5-9bab8533eddb",
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.linear_model import Ridge\n",
    "\n",
    "#criando candidatos se baseando no artigo. De 10^3 até 10^1 com 512 pontos espaçados de maneira igual\n",
    "t2_candidates = np.logspace(-3, 1, 256)\n",
    "\n",
    "#atribuindo os valores de X_train a t_train, mudando o formato para podermos fazermos os cálculos\n",
    "t_train = X_train['Time'].values.reshape(-1,1)\n",
    "\n",
    "#criando uma matriz com todos os valores, sendo cada linha correspondendo a um valor de t_train e cada coluna a divisão por valor de t2_candidates\n",
    "matrix = np.exp(-t_train/t2_candidates)\n",
    "\n",
    "#utilizamos regularização Ridge com valor de alpha (lambda) como 0.1 e definindo os valores sendo como positivo\n",
    "ridge = Ridge(alpha = 0.1, positive = True)\n",
    "\n",
    "#essa função calcula a minimização para encontrar o melhor vetor 'c'\n",
    "ridge.fit(matrix, y_train)\n",
    "\n",
    "#pegamos os valores obtidos e armazenamos em 't2_distribution'\n",
    "t2_distribution = ridge.coef_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "20f789e5-a6c6-49dd-922e-9a9abd8f0fe4",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "\n",
    "plt.figure(figsize=(10,6))\n",
    "\n",
    "plt.plot(t2_candidates, t2_distribution)\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
